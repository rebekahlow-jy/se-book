<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>CS2103/T Textbook - SLDC Process Models: Summary</title>
    <link rel="stylesheet" href="..\..\markbind\css\bootstrap.min.css">
    <link rel="stylesheet" href="..\..\markbind\css\github.min.css">
</head>
<body>
<div id="app" class="container-fluid">
    <link rel="stylesheet" href="/se-book/css/textbook.css">
<div class="website-content">
  <p><span class="dimmed"><strong>SLDC Process Models ‚û°Ô∏è</strong></span></p>
  <h2 id="summary">Summary</h2>
  <div id="main">
    <div>
      <div>
        <h4 id="recap-three">Recap <img style="height: 1em;width: 1em;margin: 0 .05em 0 .1em;vertical-align: -0.1em;" src="https://assets-cdn.github.com/images/icons/emoji/unicode/0033-20e3.png"></h4>
      </div>
      <tip-box type="success">
        <div>
          <p>üèÜ Can recall process models <img style="height: 1em;width: 1em;margin: 0 .05em 0 .1em;vertical-align: -0.1em;" src="https://assets-cdn.github.com/images/icons/emoji/unicode/0033-20e3.png"></p>
        </div>
      </tip-box>
      <panel type="seamless" header=" %%- - - - - - - - - -%%">
        <div>
          <div>
            <div>
              <panel header=":muscle: Exercises" type="info" expandable="">
                <div>
                  <panel header="Q: Sequential vs iterative approach :two:">
                    <question has-input="true">
                      <p>Discuss how sequential approach and the iterative approach can affect the following aspects of a project.</p>
                      <p>a) Quality of the final product.</p>
                      <p>b) Risk of overshooting the deadline.</p>
                      <p>c) Total project cost.</p>
                      <p>d) Customer satisfaction.</p>
                      <p>e) Monitoring the project progress.</p>
                      <p>f) Suitability for a school project</p>
                      <div slot="answer">
                        <p>a) Quality of the final product:</p>
                        <ul>
                          <li>Iterative: Frequent reworking can deteriorate the design. Frequent refactoring should be used to prevent this. Frequent customer feedback can help to improve the quality (i.e. quality as seen by the customer).</li>
                          <li>Sequential: Final quality depends on the quality of each phase. Any quality problem in any phase could result in a low quality product.</li>
                        </ul>
                        <p>b) Risk of overshooting the deadline.</p>
                        <ul>
                          <li>Iterative: Less risk. If the last iteration got delayed, we can always deliver the previous version. However, this does not guarantee that all features promised at the beginning will be delivered on the deadline.</li>
                          <li>Sequential: High risk. Any delay in any phase can result in overshooting the deadline with nothing to deliver.</li>
                        </ul>
                        <p>c) Total project cost.</p>
                        <ul>
                          <li>Iterative: We can always stop before the project budget is exceeded. However, this does not guarantee that all features promised at the beginning will be delivered under the estimated cost. (The sequential model requires us to
                            carry on even if the budget is exceeded because there is no intermediate version to fall back on).</li>
                        </ul>
                        <p>Iterative reworking of existing artifacts could add to the cost. However, this is ‚Äúcheaper‚Äù than finding at the end that we built the wrong product.</p>
                        <p>d) Customer satisfaction</p>
                        <ul>
                          <li>Iterative: Customer gets many opportunities to guide the product in the direction he wants. Customer gets to change requirements even in the middle of the product. Both these can increase the probability of customer satisfaction.</li>
                          <li>Sequential: Customer satisfaction is guaranteed only if the product was delivered as promised and if the initial requirements proved to be accurate. However, the customer is not required to do the extra work of giving frequent
                            feedback during the project.</li>
                        </ul>
                        <p>e) Monitoring project progress</p>
                        <ul>
                          <li>Iterative: Hard to measure progress against a plan, as the plan itself keeps changing.</li>
                          <li>Sequential: Easier to measure progress against the plan, although this does not ensure eventual success.</li>
                        </ul>
                        <p>f) Suitability for a school project:</p>
                        <p>Reasons to use iterative:</p>
                        <ul>
                          <li>Requirements are not fixed.</li>
                          <li>Overshooting the deadline is not an option.</li>
                          <li>Gives a chance to learn lessons from one iteration and apply them in the next.</li>
                        </ul>
                        <p>Sequential:</p>
                        <ul>
                          <li>Can save time because we minimize rework.</li>
                        </ul>
                      </div>
                    </question>
                  </panel>
                </div>
                <div>
                  <panel header="Q: Agile processes, Pair programming, Test-driven development :four:">
                    <question has-input="true">
                      <p>Find out more about the following three topics and give at least three arguments for and three arguments against each.</p>
                      <p>(a) Agile processes</p>
                      <p>(b) Pair programming</p>
                      <p>(c) Test-driven development</p>
                      <div slot="answer">
                        <p>(a) Arguments in favor of agile processes:</p>
                        <ul>
                          <li>More focus on customer satisfaction.</li>
                          <li>Less chance of building the wrong product (because of frequent customer feedback).</li>
                          <li>Less resource wasted on bureaucracy, over-documenting, contract negotiations.</li>
                        </ul>
                        <p>Arguments against agile processes (not necessarily true):</p>
                        <ul>
                          <li>It is ‚Äòjust hacking‚Äô. Not very systematic. No discipline.</li>
                          <li>It is hard to know in advance the exact final product.</li>
                          <li>It does not give enough attention to documentation.</li>
                          <li>Lack of management control (gives too much freedom to developers)</li>
                        </ul>
                        <p>(b) Arguments in favor of pair programming:</p>
                        <ul>
                          <li>It could produce better quality code.</li>
                          <li>It is good to have more than one person know about any piece of code.</li>
                          <li>It is a way to learn from each other.</li>
                          <li>It can be used to train new programmers.</li>
                          <li>Better discipline and better time management (e.g. less likely to play Farmville while working).</li>
                          <li>Better morale due to more interactions with co-workers.</li>
                        </ul>
                        <p>Arguments against pair programming:</p>
                        <ul>
                          <li>Increase in total man hours required</li>
                          <li>Personality clashes between pair-members</li>
                          <li>Workspaces need to be adapted to suit two developers working at one computer.</li>
                          <li>If pairs are rotated, one needs to know more parts of the system than in solo programming</li>
                        </ul>
                        <p>(c) Arguments in favor of TDD:</p>
                        <ul>
                          <li>Testing will not be neglected due to time pressure (because it is done first).</li>
                          <li>Forces the developer to think about what the component should be before jumping into implementing it.</li>
                          <li>Optimizes programmer effort (i.e. if all tests pass, there is no need to add any more functionality).</li>
                          <li>Forces us to automate all tests.</li>
                        </ul>
                        <p>Arguments against TDD (not necessarily true):</p>
                        <ul>
                          <li>Since tests can be seen as ‚Äòexecutable specifications‚Äô, programmers tend to neglect others forms of documentation.</li>
                          <li>Promotes ‚Äòtrial-and-error‚Äô coding instead of making programmers think through their algorithms (i.e. ‚Äòjust keep hacking until all tests pass‚Äô).</li>
                          <li>Gives a false sense of security. (what if you forgot to test certain scenarios?)</li>
                        </ul>
                        <p>Not intuitive. Some programmer might resist adopting TDD.</p>
                      </div>
                    </question>
                  </panel>
                </div>
              </panel>
            </div>
          </div>
        </div>
      </panel>
    </div>
  </div>
</div>
</div>
</body>
<script src="..\..\markbind\js\vue.min.js"></script>
<script src="..\..\markbind\js\vue-strap.min.js"></script>
<script src="..\..\markbind\js\setup.js"></script>
</html>
